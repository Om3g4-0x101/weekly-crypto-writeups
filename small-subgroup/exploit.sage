# The Baby-Step Giant Step (BSGS) algorithm helps reduce the complexity of calculating the discrete logarithm
# g_i**x_i mod p_i = h_i to O(sqrt(p_i)) instead of O(p_i) with traditional brute force.  The way BSGS works is that
# We rewrite the discrete logarithm x_i in terms of i*m + j, where m = ceil(sqrt(n)).  This allows for a meet-in-the-middle
# style calculation of x_i .As, we first calculate g**j mod G for every 0 <= j < m and store them as key-value pair of (j,g**j) in a log_table, and then calculating y= A * g**(-i*m) mod p for 
# 0<= i <= m (upper limit is kept to m as i*m will be m^2(>= p_i) when i=m) . 
from Crypto.Util.number import *
from Crypto.Cipher import AES

def BSGS(g, A, G):
	n = G.order() - 1
	m = ceil(sqrt(n)) + 1
	log_table = {}
	y=A
	for j in range(m):
		log_table[j] = (j, g**j)
	
	for i in range(m):
		for x in log_table.keys():
			if log_table[x][1] == y:
				# When we find a collision say i=k and x=x_0 , i.e. g**x_0 == A * g**-(k * m)),then this implies g**(x_0+k**m)==A , hence the discrete lograthim will be x_0+k**m !
				return i * m + log_table[x][0] 

		y = A*(g**-(i*m)) # repeatedly multiplying y by inverse element `g**-m`

	return None


def pohlig_hellman(g, A, F):
	#We will be implementing pohlig hellman algorithm to find the dicrete logarithm of A=g^x mod (F)
	p = F.order() # order denotes the number of elements in the group
	factors = [p_i ** e_i for (p_i, e_i) in factor(F.order() - 1)]#finding all the prime factors raised to their respective exponents
	crt_array = []
	print(f"[+] Factored p - 1 into {factors}")

	for p_i in factors:
		# The Pohlig-Hellman attack on Diffie-Hellman works as such:
		# Given the generator, public keys of either Alice or Bob, as well as the multiplicative order Of the group (which in Diffie-Hellman is p - 1 due to prime modulus),
		# one can factor the group order into smaller primes (provided the prime `q` used in p=2*q+1 is unsafe )
		# By Lagrange's theorem, we have that the order of a subgroup divides the order of a group . Using this theorem , we can confine the group to smaller subgroups(p_i) and hence have to look for elements recursively in the finite field of size p_i only
		
		g_i = g ** ((p - 1) // p_i)
		h_i = A ** ((p - 1) // p_i)
		
		#g_i and h_i now belong to the subgroup of order p_i
		
		x_i = BSGS(g_i, h_i, GF(p_i)) # Field is reduced to the size of p_i 
		
		#x_i is congruent to x modulo p_i

		if x_i != None:
			print(f"[+] Found discrete logarithm {x_i} for factor {p_i}")
			crt_array += [x_i]
		elif x_i == None:
			print(f"[x] Did not find discrete logarithm for factor {p_i}")

	#Now, we have a collection of equations of `x congruent to x_i modulo p_i` , for all factors `p_i`. Passing the list of x_i and p_i to crt function will give a solution to the equations using crt.
	return crt(crt_array, factors)

def exploit(g,A,F):
	print(f"[+] Attempting Pohlig-Hellman factorization with \n g = {g}\nA = {A}\n F is a finite field with order {F.order()}\n" )
	a = pohlig_hellman(g, A, F)
	assert g**a == A
	print(f"[+] Recovered exponent a such that g**a = A through Pohlig-Hellman: {a}")

if __name__ == "__main__":
	F = GF(11875868880593531537558080687524960044868885561793758658267796536203357260621413918548941477848074144676353383736943526316257683335554099036570968810232115970943243407523821811650322210929205379079045803976193435625769520659182167923340397156754922205883365761984252112485861211625726012196057407751553066314566359147427833867302754303210395755335911384953740487778650973100850831961972218245584256611542768240293640603028359878596793894483127256401704207088032606669466064627)
	A =  F(0x46b51a52c868299ca1591347df8b5cd6156994ac374be0e1e4b679cf357b2b45b45229621f13d06fcaa47e9959430ddbb54d5607bf0dddc501aa1467579a2b57c77cd000e170315cbf206b97e3d040cb69afa8b11807ac7c20f149aaaf55354649858c12dc3f6fd800bead7776183373b7fd21b2c541fc6276a41236c3dc4d3d0284a995cc3ef75f028c31ce54888e50c5929aeb0294a0de1232b527380b313e2f92fec3990c9fafb822248fbd29addeb4036f92643577278029cacd061122d5effc22d30d8)
	B =  F(0x24ec7753a9baba450f2235731b3527599091f8034c8f8e5e486ffa351403f502cfbd86d2a8eb2aa921bd46c7b0a27798075a2582d33de0e6f9056e1b74638f3ffccd05022fc2478b8463adb18921f9a161416f93081a27f634254be8ba4807ff91619f0aff25e13ad6f81169c3adaaac197f9e33640e652d7973b151972e4e8644c70db2eca76ab17728b84c88e973ced7e7127bddb04ab7b428148be45071f640dc99628ae56dc8475052011f70d33e68c103d1079f3797b4388f20dc7cde55cce1b62ea3d)
	enc = bytes.fromhex("7d984f52c2b334c9b2f6eff7421c8f07cd352c7a22d3c8cc1f1f6fcdf613a12d")
    g = F(2) 
	# F(x) denoting that element x belongs to the finite field F
    #we are going to find the alice_secret and then find their shared secret using B**alice_secret which would be same as pow(B,alice_secret,p) as B belongs to B
	alice_secret=exploit(g,A,F)
	shared_secret=B**alice_secret
	key = long_to_bytes(shared_secret)
	key=key[:16]
	cipher = AES.new(key, AES.MODE_ECB)
	print ("FLAG : ", cipher.decrypt(enc))
