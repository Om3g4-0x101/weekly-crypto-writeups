# The Baby-Step Giant Step (BSGS) algorithm helps reduce the complexity of calculating the discrete logarithm
# g_i**x_i mod p_i = h_i to O(sqrt(p_i)) instead of O(p_i) with traditional brute force.  The way BSGS works is that
# We rewrite the discrete logarithm x_i in terms of i*m + j, where m = ceil(sqrt(n)).  This allows for a meet-in-the-middle
# style calculation of x_i .As, we first calculate g**j mod G for every 0 <= j < m and store them as key-value pair of (j,g**j) in a log_table, and then calculating y= A * g**(-i*m) mod p for 
# 0<= i <= m (upper limit is kept to m as i*m will be m^2(>= p_i) when i=m) . 
# The Pohlig-Hellman attack on Diffie-Hellman works as such:
# Given the generator, public keys of either Alice or Bob, as well as the multiplicative order Of the group (which in Diffie-Hellman is p - 1 due to prime modulus),
# one can factor the group order into smaller primes (provided the prime `q` used in p=2*q+1 is unsafe )
# By Lagrange's theorem, we have that the order of a subgroup divides the order of a group . Using this theorem , we can confine the group to smaller subgroups(p_i) and hence have to look for elements recursively in the finite field of size p_i only
# When we find a collision say i=k and x=x_0 , i.e. g**x_0 == A * g**-(k * m)),then this implies g**(x_0+k**m)==A , hence the discrete lograthim will be x_0+k**m !
def BSGS(g, A, G):
	n = G.order() - 1
	m = ceil(sqrt(n)) + 1
	y = A
	log_table = {}

	for j in range(m):
		log_table[j] = (j, g^j)

	inv = g^-m
	
	for i in range(m):
		for x in log_table.keys():
			if log_table[x][1] == y:
				return i * m + log_table[x][0]
	
		y *= inv

	return None

def pohlig_hellman(g, A, F, debug=True):
	""" Attempts to use Pohlig-Hellman to compute discrete logarithm of A = g^a mod p"""
	p = F.order() 
	factors = [p_i ** e_i for (p_i, e_i) in factor(F.order() - 1)]
	crt_array = []

	if debug:
		print("[x] Factored |F_p| = p - 1 into %s" % factors)

	for p_i in factors:
		g_i = g ** ((p - 1) // p_i)
		h_i = A ** ((p - 1) // p_i)
		x_i = BSGS(g_i, h_i, GF(p_i))
		if debug and x_i != None:
			print("[x] Found discrete logarithm %d for factor %d" % (x_i, p_i))
			crt_array += [x_i]
		elif x_i == None:
			print("[] Did not find discrete logarithm for factor %d" % p_i)


	return crt(crt_array, factors)

def exploit(g,A,F):
	print("Attempting Pohlig-Hellman factorization with \ng = %d\nA = %d\nF is a finite field with order %d\n" 
		% (g, A, F.order()))
	a = pohlig_hellman(g, A, F)
	assert g**a == A
	print("[x] Recovered exponent a such that g^a = A through Pohlig-Hellman: %d" % a)

if __name__ == "__main__":
    F = GF(57709937095736748707766266121061070270736984391755037161746092145800428699901267064992500100452120323)
    g = F(6862230423439704800599635372588241766443241516687730839067524319148439812277727596294137046769507421)
    A = F(35109578903356652282583091316434534076329783688364219256182342958633264942467664701017935316905285284)
    exploit(g,A,F)
